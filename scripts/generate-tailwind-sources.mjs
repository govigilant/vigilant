import { promises as fs } from 'node:fs';
import path from 'node:path';

const projectRoot = path.resolve(process.cwd());
const cssDir = path.join(projectRoot, 'resources', 'css');
const packagesDir = path.join(projectRoot, 'packages');
const outputFile = path.join(cssDir, 'tailwind.sources.css');

const STATIC_SOURCES = [
  "../views/**/*.blade.php",
  "../../vendor/laravel/framework/src/Illuminate/Pagination/resources/views/*.blade.php",
  "../../vendor/laravel/jetstream/**/*.blade.php",
  "../../vendor/ramonrietdijk/livewire-tables/resources/**/*.blade.php",
];

const IGNORED_DIRS = new Set(['.', '..', 'vendor', 'node_modules']);

async function directoryExists(targetPath) {
  try {
    const stat = await fs.stat(targetPath);
    return stat.isDirectory();
  } catch {
    return false;
  }
}

async function collectPackageSources(baseDir) {
  const entries = await fs.readdir(baseDir, { withFileTypes: true }).catch(() => []);
  const sources = [];

  for (const entry of entries) {
    if (!entry.isDirectory()) continue;
    if (IGNORED_DIRS.has(entry.name) || entry.name.startsWith('.')) continue;

    const pkgDir = path.join(baseDir, entry.name);
    const viewsDir = path.join(pkgDir, 'resources', 'views');
    if (await directoryExists(viewsDir)) {
      const relativePath = path.relative(cssDir, viewsDir).replace(/\\/g, '/');
      sources.push(`${relativePath}/**/*.blade.php`);
    }
  }

  return sources;
}

async function collectAllSources() {
  const dynamicSources = new Set();

  if (await directoryExists(packagesDir)) {
    const topLevelSources = await collectPackageSources(packagesDir);
    topLevelSources.forEach((source) => dynamicSources.add(source));

    const topLevelEntries = await fs.readdir(packagesDir, { withFileTypes: true }).catch(() => []);
    for (const entry of topLevelEntries) {
      if (!entry.isDirectory()) continue;
      if (IGNORED_DIRS.has(entry.name) || entry.name.startsWith('.')) continue;

      const nestedPackagesDir = path.join(packagesDir, entry.name, 'packages');
      if (await directoryExists(nestedPackagesDir)) {
        const nestedSources = await collectPackageSources(nestedPackagesDir);
        nestedSources.forEach((source) => dynamicSources.add(source));
      }
    }
  }

  const allSources = [...STATIC_SOURCES, ...dynamicSources];
  return Array.from(new Set(allSources)).sort((a, b) => a.localeCompare(b));
}

function buildFileContent(sources) {
  const header = [
    '/*',
    ' * This file is auto-generated by scripts/generate-tailwind-sources.mjs.',
    ' * Do not edit this file manually.',
    ' */',
    '',
  ].join('\n');

  const lines = sources.map((pattern) => `@source '${pattern}';`);
  return `${header}${lines.join('\n')}\n`;
}

async function main() {
  const sources = await collectAllSources();
  const fileContent = buildFileContent(sources);
  await fs.writeFile(outputFile, fileContent, 'utf8');
}

main().catch((error) => {
  console.error('Failed to generate Tailwind sources:', error);
  process.exitCode = 1;
});
